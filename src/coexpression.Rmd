---
title: "CoExpression Networks"
author: "João Vitor F. Cavalcante"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(CEMiTool)
library(DESeq2)
library(dplyr)
library(biomaRt)
library(org.Hs.eg.db)
```

# CemiTool

## Ler dados de expressão

```{r}
# Carregar dado de expressão
load("./results/dds.RData")

# Carregar genes DGE
load("./results/res_dge.RData")

metadata <- readr::read_csv("data/metadata.txt") %>% 
  dplyr::filter(Run %in% colnames(dds)) %>% 
  dplyr::select(Run, subtype) %>% 
  as.data.frame()

# Obter expressão normalizada e filtrar genes DGE
vst <- vst(dds)
counts <- assay(vst)
counts <- as.data.frame(counts[rownames(counts) %in% rownames(res_dge),])
```

## Traduzir identificadores

```{r}
ensembl <- useMart("ENSEMBL_MART_ENSEMBL")

ensembl <- useDataset(dataset = "hsapiens_gene_ensembl", mart = ensembl)

ids <- getBM(attributes = c("hgnc_symbol", "ensembl_gene_id", "ensembl_peptide_id", "entrezgene_id"),
             filters = "ensembl_gene_id",
             values = rownames(counts),
             mart = ensembl)
```

```{r}
kegg_to_entrez <- as.data.frame(org.Hs.egPATH2EG)

kegg_to_symbol <- ids %>% 
  mutate(entrezgene_id = as.character(entrezgene_id)) %>% 
  inner_join(kegg_to_entrez, by = c("entrezgene_id" = "gene_id"))

save(kegg_to_symbol, file="results/pathways_for_cea.RData")
```

## Adquirir interações PPI

```{r}
# Para fazer este mapeamento, quando submetemos uma requisição à API do string programaticamente, 
# temos que concatenar os identificadores e separá-los com o símbolo "%0d".
genes_hgnc_concatenado <- paste0(ids$hgnc_symbol, collapse = "%0d") 

# Fazer a solicitação a API do STRING
req <- RCurl::postForm(
  "https://string-db.org/api/tsv/get_string_ids",
  identifiers = genes_hgnc_concatenado,
  echo_query = "1",
  species = "9606"
)
map_ids <- read.table(text = req, sep = "\t", header = T, quote = "")
```


```{r}
# Função para combinar os scores de acordo com o algoritmo usado pelo STRING
combinescores <- function(dat, evidences = "all", confLevel = 0.4) {
  if(evidences[1] == "all"){
    edat<-dat[,-c(1,2,ncol(dat))]
  } else {
    if(!all(evidences%in%colnames(dat))){
      stop("NOTE: one or more 'evidences' not listed in 'dat' colnames!")
    }
    edat<-dat[,evidences]
  }
  if (any(edat > 1)) {
    edat <- edat/1000
  }
  edat<-1-edat
  sc<- apply(X = edat, MARGIN = 1, FUN = function(x) 1-prod(x))
  dat <- cbind(dat[,c(1,2)],combined_score = sc)
  idx <- dat$combined_score >= confLevel
  dat <-dat[idx,]
  return(dat)
}

#Concatenar os identificadores do string para a requisição
genes_string_concatenado <- paste0(unique(map_ids$stringId), collapse = "%0d") 

# Requisição para o método 'network'
req2 <- RCurl::postForm(
  "https://string-db.org/api/tsv/network",
  identifiers = genes_string_concatenado, # identificadores do stringID, obtidos na etapa anterior
  required_core = "0", # score mínimo para cada interação
  species     = "9606" # espécie (H. sapiens)
)
int_network <- read.table(text = req2, sep = "\t", header = T)
int_network <- unique(int_network)

int_network <- combinescores(int_network, evidences = c("ascore", "escore", "dscore"), confLevel = 0.9)
```


```{r}
# Remover o identificador de espécie em cada ENSP
int_network$stringId_A <- substring(int_network$stringId_A, 6, 1000)
int_network$stringId_B <- substring(int_network$stringId_B, 6, 1000)

# Filtrar a rede, mantendo apenas os ENSP que estão presentes no nosso dataframe inicial
idx1 <- int_network$stringId_A %in% ids$ensembl_peptide_id
idx2 <- int_network$stringId_B %in% ids$ensembl_peptide_id
int_network <- int_network[idx1 & idx2,]

# Manter somente os nomes dos genes na tabela de interação
int_network$ENSG_A <- ids$ensembl_gene_id[match(int_network$stringId_A, ids$ensembl_peptide_id)]
int_network$ENSG_B <- ids$ensembl_gene_id[match(int_network$stringId_B, ids$ensembl_peptide_id)]
int_network <- int_network[, c("ENSG_A", "ENSG_B")]

save(int_network, file="results/network_for_cea.RData")
```


## Rodar o CEMiTool

```{r}
load("results/network_for_cea.RData")
load("results/pathways_for_cea.RData")

paths <- kegg_to_symbol[, c("path_id", "ensembl_gene_id")]

paths <- setNames(paths, c("term", "gene"))

cem <-
  cemitool(
    counts,
    annot = metadata,
    sample_name_column = "Run",
    class_column = "subtype",
    paths,
    interactions = int_network,
    filter = TRUE,
    plot = TRUE,
    verbose = TRUE
  )
```


## Número de módulos encontrados

```{r}
nmodules(cem)

head(module_genes(cem))
```

## Identificar top n genes com maior conectivadade em cada módulo

```{r}
n <- 10

hubs <- get_hubs(cem, n)

hubs
```

## Enriquecimento dos módulos

The size and intensity of the circles in the figure correspond to the Normalised Enrichment Score (NES), which is the enrichment score for a module in each class normalised by the number of genes in the module

```{r}
# generate heatmap of gene set enrichment analysis
show_plot(cem, "gsea")
```


## Visualizar padrões de expressão nos módulos

```{r}
# plot gene expression within each module
plots <- show_plot(cem, "profile")
plots[1]
```

## Over-representation analysis

```{r}
plots <- show_plot(cem, "ora")
plots[1]
```

## Interações

```{r}
plots <- show_plot(cem, "interaction") # view the plot for the first module
plots[1]
```

```{r}
# Cria relatorio do CEMiTool em HTML no diretório abaixo
# (Tem que ser um diretório inexistente)
generate_report(cem, directory="results/cemitool_report/")
```

